# -*- coding: utf-8 -*-
"""
Created on Wed Nov  9 18:51:51 2022

@author: aaron.hastings
"""

import pandas as pd
import numpy as np
from .Compute_REMELs import Compute_REMELs
from inspect import currentframe, getframeinfo 

class DANA_Noise_Data:
    # User Inputs
    # number_of_lanes         = Total Number of Lanes inboth directions, 
    #                           e.g. for 2 NB & 2 SB lanes, number_of_lanes = 4
    # link_grade = Roadway Grade for Each Link, no assumption is made as to which links are paired
    #                         = 100 * rise / run
    #
    # df_DANA = Dataframe containing all input data except the three values above:
    #           Columns of df are generated by the DANA tool and include:
    #                TMC, DATE, HOUR, ROAD, DIRECTION, STATE, COUNTY,
    #                start_latitude, start_longitude, end_latitude, end_longitude
    #                TMC_LENGTH, road_order, f_system, thrulanes, aadt, 
    #                AADT_Single_Unit, aadt_combinations, TT_ALL_vehs, TT_PASS,
    #                TT_TRUCK, SPEED_ALL_vehs, SPEED_PASS, SPEED_TRUCK,
    #                PCT_NOISE_AUTO, PCT_NOISE_MEDIUM, PCT_NOISE_HEAVY,
    #                PCT_NOISE_BUS, PCT_NOISE_MC
    #           
    #      For a description of each of these columns, see Appendix C, 
    #           Table 4.4 on page 80 of the DANA User's Guide.
    #           https://www.fhwa.dot.gov/environment/air_quality/methodologies/
    #           dana/dana_userguide_r2.pdf
    #           - OR -
    #           https://www.fhwa.dot.gov/environment/noise/traffic_noise_model/
    #           tnm_aide_userguide/
    #
    # Change Log from TNMAide 2.0
    # 1) Refactored code into several scripts and classes
    # 2) Removed need to pass number of links. This is now computed from data
    # 3) Removed default computation of future condition, handled as a separate call with modified data
    # 4) Removed computation of worst hour of all hours of all 365 (366) days
    # 5) Intermediate dataframe created that holds all relevant hourly data, i.e.
    #    traffic volumes, speeds and noise levels
    #    Different TMCs are held in different columns instead of different rows
    #    i.e. single row for each date/hour combination
    # 6) Added data validation for improved robustness
    # 7) Where possible added data conversion for improved flexibility and robustness
       
    
    def __init__(self, df_DANA, link_grade, robust_speeds = False):
        # Init Steps:
        #  1) Validate Inputs
        #       for each link, there must be a link_grade element
        #       Note: Pairing of links is done explicitly in the Paired_Link_Sound_Data class, not here
        #       Note: Link_Sound_Data does not require a median_width, as this is addressed in the Paired_Link_Sound_Data class
        #  2) Convert df_DANA to minimal dataframe:
        #       df_Traffic_Noise
        #       links are in different columns rather than different rows (easier sorting)
        #  3) Compute LAeq for each hour:
        #       for each link         
        
        # Validate INPUTS
        # link_grade validation
        #----------------------------------------------------------------------
        if isinstance(link_grade, tuple):
            # Convert to preferred format, list --> can't have a tuple with one element
            link_grade = list(link_grade)     
        if isinstance(link_grade, np.ndarray):
            link_grade = list(link_grade)
            
        if not isinstance(link_grade, list):
            if isinstance(link_grade, int):
                # Convert int to preferred format, float (done seperately for readability)
                link_grade = float(link_grade)
            if not isinstance(link_grade, float):
                
                frameinfo = getframeinfo(currentframe())
                print(frameinfo.filename, frameinfo.lineno)
                print('')
                
                print('-----DANA_Noise_Data.__init__.')
                print('-----Roadway grade must be a number between [-8.0 and 8.0].')   
                # TBD add GUI error message
                return None
            if abs(link_grade) > 8.0:
                
                frameinfo = getframeinfo(currentframe())
                print(frameinfo.filename, frameinfo.lineno)
                print('')
                
                print('-----DANA_Noise_Data.__init__.')
                print('-----Roadway grade must be a number between [-8.0 and 8.0].')   
                # TBD add GUI error message
                return None
            link_grade = [link_grade]
        else: # it is a list and we need to check each element
            tmp = []    
            for grade in link_grade:
                if not isinstance(grade, (float, int)):
                    
                    frameinfo = getframeinfo(currentframe())
                    print(frameinfo.filename, frameinfo.lineno)
                    print('')
                
                    print('-----DANA_Noise_Data.__init__.')
                    print('-----Roadway grade must be a number between [-8.0 and 8.0].')   
                    # TBD add GUI error message
                    return None
                tmp.append(float(grade))
                if abs(grade) > 8.0:
                    
                    frameinfo = getframeinfo(currentframe())
                    print(frameinfo.filename, frameinfo.lineno)
                    print('')
                    
                    print('-----DANA_Noise_Data.__init__.')
                    print('-----Roadway grade must be a number between [-8.0 and 8.0].')   
                    # TBD add GUI error message
                    return None
            link_grade = list(tmp)   

        self.link_grade = link_grade
        
        # Validate the Dataframe Input
        #----------------------------------------------------------------------
        self.Validate_Data(df_DANA) # Calls --> Validate_Data method 
                                    # Creates new, reformatted dataframe (df_Traffic_Noise)
                                    # Creates additional meta data at object level (see self in variable explorer)
                                    #    e.g.: county = list of county names for each link
                                    #          end_lat = list of end lats for each link
                                    #          link_grade = list of grades for links
                                    #          median_width = float for single set of matched links
                                    #          tmc_dictionary = dictionary between df_Traffic_Noise col names and tmc names
        if self.df_Traffic_Noise is None:
            return None
        
        # Final validation of consistency between dataframe and other user inputs
        #----------------------------------------------------------------------
        number_of_TMCs = len(self.tmc)
            
        if isinstance(self.link_grade, list):
            number_of_grades = len(self.link_grade)
        else:
            number_of_grades = 1

        # Make sure number of TMCs match number or grade inputs        
        #----------------------------------------------------------------------
        if number_of_TMCs != number_of_grades:
            print('-----DANA_Noise_Data.__init__.')
            print('-----Must provide a roadway grade for each link.')   
            # TBD add GUI error message
            return None
        
        # Fill in SPL based on REMELs equations for each vehicle/TMC/hour
        #----------------------------------------------------------------------
        if robust_speeds:
            self.Compute_Hourly_SPL_All_Veh_All_Links()
        else:
            self.Compute_Hourly_SPL_All_Veh_All_Links_Vector()
        return
        
        
    def Validate_Data(self, df_DANA):
        # Standard format is for one year of hourly data for two adjacent links
        #      can be standard or leap year
        # Non-stanard format includes only one link, or fewer than a year's data
        # Number of Hourly Samples in Standard Year = 365 * 24 =  8,760 per link
        #                                                      = 17,520 per paired links
        # Number of Hourly Samples in Leap Year = 366 * 24     =  8,784 per link
        #                                                      = 17,568 per paired links
        # 
        # Expected Dataframe Columns
        # ['TMC' 'DATE' 'HOUR' 'ROAD' 'DIRECTION' 'STATE' 'COUNTY' 'START_LATITUDE'
        # 'START_LONGITUDE' 'END_LATITUDE' 'END_LONGITUDE' 'TMC_LENGTH'
        # 'ROAD_ORDER' 'F_SYSTEM' 'THRULANES' 'MAADT' 'AADT' 'AADT SINGLE UNIT'
        # 'AADT_COMBINATIONS' 'TT_ALL_VEHS' 'TT_PASS' 'TT_TRUCK' 'SPEED_ALL_VEHS'
        # 'SPEED_PASS' 'SPEED_TRUCK' 'PCT_NOISE_AUTO' 'PCT_NOISE_MEDIUM'
        # 'PCT_NOISE_HEAVY' 'PCT_NOISE_BUS' 'PCT_NOISE_MC']
        #
        # Note: only 'MAADT' is used for volumes, not 'AADT' 'AADT SINGLE UNIT' or 'AADT_COMBINATIONS'
        # Note: 'SPEED_ALL_VEHS' is used only for MCs
        #       'SPEED_PASS' is used only for Autos
        #       'SPEED_TRUCK' is used for MTs, HTs and Buses
        #
        # Data Needed for Each Row in the dataframe:
        # DATE, HOUR, MAADT, SPEED_ALL_VEHS, SPEED_PASS, SPEED_TRUCK, PCT_NOISE_AUTO,
        # PCT_NOISE_MEDIUM, PCT_NOISE_HEAVY, PCT_NOISE_BUS, PCT_NOISE_MC
        #
        # These columns will ulitmately be renamed to 
        #
        # DATE, HOUR, AADT, SPD_ALL, SPD_AT, SPD_HT, PCT_AT,
        # PCT_MT, PCT_HT, PCT_BUS, PCT_MC
        #
        #
        # All others can be stored once at the class object level
        
        # Reset index
        df_DANA.reset_index(drop=True, inplace=True)
        
        # Make all column names upper case for robustness
        # col_names = df_DANA.columns.values
        # new_name_dict = {} 
        # for name in col_names:
        #     new_name_dict[name] = name.upper() 
        # df_DANA.rename(columns=new_name_dict, inplace=True)
        df_DANA.columns = df_DANA.columns.str.upper()
        
        # Check to make sure there are no missing speeds 
        # (fast computations depend on all speed data being present)
        if any(df_DANA['SPEED_ALL'].isna()):
            
            frameinfo = getframeinfo(currentframe())
            print(frameinfo.filename, frameinfo.lineno)
            print('')
                    
            print('Missing speed data')
            return
        if any(df_DANA['SPEED_PASS'].isna()):
            
            frameinfo = getframeinfo(currentframe())
            print(frameinfo.filename, frameinfo.lineno)
            print('')
            
            print('Missing speed data')
            return
        if any(df_DANA['SPEED_TRUCK'].isna()):
            
            frameinfo = getframeinfo(currentframe())
            print(frameinfo.filename, frameinfo.lineno)
            print('')
            
            print('Missing speed data')
            return
        
        # TMCS
        ######################################################################
        # Get the TMCs
        if any(df_DANA.columns.values == 'TMC'):
            self.tmc = list(pd.unique(df_DANA['TMC']))
            self.number_of_links = len(self.tmc)
            # Create dictionary associating each TMC with and L# label
            self.tmc_dictionary = {}
            cnt = 0
            for tmc in self.tmc:
                cnt = cnt + 1
                self.tmc_dictionary['L' + str(cnt)] = tmc 
            if self.number_of_links < 1:
                
                frameinfo = getframeinfo(currentframe())
                print(frameinfo.filename, frameinfo.lineno)
                print('')
            
                print('-----DANA_Noise_Data.__init__.')
                print('-----TMC column of input dataframe was empty.')   
                # TBD add GUI error message
                self.df_Traffic_Noise = None
                return
        else:
            
            frameinfo = getframeinfo(currentframe())
            print(frameinfo.filename, frameinfo.lineno)
            print('')
            
            print('-----DANA_Noise_Data.__init__.')
            print('-----TMC data must be labeled in df_DANA input dataframe.')   
            # TBD add GUI error message
            self.df_Traffic_Noise = None
            return
        
        # Get indeces for TMC transition
        self.link_start_idx = np.array([],int)
        for tmc in self.tmc:
            self.link_start_idx = np.append(self.link_start_idx, df_DANA.TMC.eq(tmc).idxmax())
        
        # ROAD NAMES
        ######################################################################
        # Get the Road Names
        self.road_names = []
        if any(df_DANA.columns.values == 'ROAD'):
            for idx in self.link_start_idx:
                self.road_names.append(df_DANA.loc[idx,'ROAD'])   
        else:
            
            frameinfo = getframeinfo(currentframe())
            print(frameinfo.filename, frameinfo.lineno)
            print('')
            
            print('-----DANA_Noise_Data.__init__.')
            print('-----Warning, no roadway name data found. Default names being used.')   
            # TBD add GUI error message
            cnt = 0
            for idx in self.link_start_idx:
                cnt = cnt + 1
                self.road_names.append('ROAD ' + str(cnt))   

        # ROAD DIRECTION
        ######################################################################
        # Get the Direction for each TMC
        self.directions = []
        if any(df_DANA.columns.values == 'DIRECTION'):
            for idx in self.link_start_idx:
                self.directions.append(df_DANA.loc[idx,'DIRECTION'])   
        else:
            
            frameinfo = getframeinfo(currentframe())
            print(frameinfo.filename, frameinfo.lineno)
            print('')
            
            print('-----DANA_Noise_Data.__init__.')
            print('-----Warning, no roadway direction data found. NA being used for all TMCs.')   
            # TBD add GUI error message
            for idx in self.link_start_idx:
                self.directions.append('NA')  

        # ROAD STATE
        ######################################################################
        # Get the State that each TMC resides in
        self.state = []
        if any(df_DANA.columns.values == 'STATE'):
            for idx in self.link_start_idx:
                self.state.append(df_DANA.loc[idx,'STATE'])   
        else:
            
            frameinfo = getframeinfo(currentframe())
            print(frameinfo.filename, frameinfo.lineno)
            print('')
            
            print('-----DANA_Noise_Data.__init__.')
            print('-----Warning, no roadway state data found. NA being used for all TMCs.')   
            # TBD add GUI error message
            for idx in self.link_start_idx:
                self.state.append('NA')  
        
        # ROAD COUNTY
        ######################################################################
        # Get the COUNTY that each TMC resides in
        self.county = []
        if any(df_DANA.columns.values == 'COUNTY'):
            for idx in self.link_start_idx:
                self.county.append(df_DANA.loc[idx,'COUNTY'])   
        else:
            
            frameinfo = getframeinfo(currentframe())
            print(frameinfo.filename, frameinfo.lineno)
            print('')
            
            print('-----DANA_Noise_Data.__init__.')
            print('-----Warning, no roadway county data found. NA being used for all TMCs.')   
            # TBD add GUI error message
            for idx in self.link_start_idx:
                self.county.append('NA')
                
        # ROAD START_LATITUDE
        ######################################################################
        # Get the START_LATITUDE for each TMC
        self.start_lat = []
        if any(df_DANA.columns.values == 'START_LATITUDE'):
            for idx in self.link_start_idx:
                self.start_lat.append(df_DANA.loc[idx,'START_LATITUDE'])   
        else:
            
            frameinfo = getframeinfo(currentframe())
            print(frameinfo.filename, frameinfo.lineno)
            print('')
            
            print('-----DANA_Noise_Data.__init__.')
            print('-----Warning, no roadway start lattitude data found. 0.0 being used for all TMCs.')   
            # TBD add GUI error message
            for idx in self.link_start_idx:
                self.start_lat.append(0.0)

        # ROAD START_LONGITUDE
        ######################################################################
        # Get the START_LATITUDE for each TMC
        self.start_long = []
        if any(df_DANA.columns.values == 'START_LONGITUDE'):
            for idx in self.link_start_idx:
                self.start_long.append(df_DANA.loc[idx,'START_LONGITUDE'])   
        else:
            
            frameinfo = getframeinfo(currentframe())
            print(frameinfo.filename, frameinfo.lineno)
            print('')
            
            print('-----DANA_Noise_Data.__init__.')
            print('-----Warning, no roadway start longitude data found. 0.0 being used for all TMCs.')   
            # TBD add GUI error message
            for idx in self.link_start_idx:
                self.start_long.append(0.0)
                
        # ROAD END_LATITUDE
        ######################################################################
        # Get the START_LATITUDE for each TMC
        self.end_lat = []
        if any(df_DANA.columns.values == 'END_LATITUDE'):
            for idx in self.link_start_idx:
                self.end_lat.append(df_DANA.loc[idx,'END_LATITUDE'])   
        else:
            
            frameinfo = getframeinfo(currentframe())
            print(frameinfo.filename, frameinfo.lineno)
            print('')
            
            print('-----DANA_Noise_Data.__init__.')
            print('-----Warning, no roadway end lattitude data found. 0.0 being used for all TMCs.')   
            # TBD add GUI error message
            for idx in self.link_start_idx:
                self.end_lat.append(0.0)

        # ROAD END_LONGITUDE
        ######################################################################
        # Get the START_LATITUDE for each TMC
        self.end_long = []
        if any(df_DANA.columns.values == 'END_LONGITUDE'):
            for idx in self.link_start_idx:
                self.end_long.append(df_DANA.loc[idx,'END_LONGITUDE'])   
        else:
            
            frameinfo = getframeinfo(currentframe())
            print(frameinfo.filename, frameinfo.lineno)
            print('')
            
            print('-----DANA_Noise_Data.__init__.')
            print('-----Warning, no roadway end longitude data found. 0.0 being used for all TMCs.')   
            # TBD add GUI error message
            for idx in self.link_start_idx:
                self.end_long.append(0.0)

        # ROAD TMC_LENGTH
        ######################################################################
        # Get the START_LATITUDE for each TMC
        self.tmc_length = []
        if any(df_DANA.columns.values == 'TMC_LENGTH'):
            for idx in self.link_start_idx:
                self.tmc_length.append(df_DANA.loc[idx,'TMC_LENGTH'])   
        else:
            
            frameinfo = getframeinfo(currentframe())
            print(frameinfo.filename, frameinfo.lineno)
            print('')
            
            print('-----DANA_Noise_Data.__init__.')
            print('-----Warning, no roadway length data found. 0.0 being used for all TMCs.')   
            # TBD add GUI error message
            for idx in self.link_start_idx:
                self.tmc_length.append(0.0)

        # Create new dataframe using only needed columns
        df_Min_Data_Needed = df_DANA[['TMC', 'DATE', 'HOUR', 'MAADT', 'SPEED_ALL', 'SPEED_PASS', 'SPEED_TRUCK', 
                   'PCT_NOISE_AUTO', 'PCT_NOISE_MED_TRUCK', 'PCT_NOISE_HVY_TRUCK', 'PCT_NOISE_BUS', 'PCT_NOISE_MC']].copy()

        # Move TMC to be after Hour - This is the last time that it is this easy to switch
        df_Min_Data_Needed.insert(2, 'TMC', df_Min_Data_Needed.pop('TMC'))

        # Final Renaming before regrouping
        link_name_dict = { 'DATE': 'DATE', 
                   'HOUR': 'HOUR', 
                   'MAADT': 'MAADT', 
                   'SPEED_ALL': 'SPD_ALL', 
                   'SPEED_PASS': 'SPD_AT',
                   'SPEED_TRUCK': 'SPD_HT', 
                   'PCT_NOISE_AUTO': 'PCT_AT', 
                   'PCT_NOISE_MED_TRUCK': 'PCT_MT', 
                   'PCT_NOISE_HVY_TRUCK': 'PCT_HT', 
                   'PCT_NOISE_BUS': 'PCT_BUS', 
                   'PCT_NOISE_MC': 'PCT_MC' }
        df_Min_Data_Needed.rename(columns=link_name_dict, inplace=True)
        
        # TBD SHOULD DO SOME MORE VALIDATION OF COLS IN DICT ABOVE, E.G. MAKE SURE THEY ARE NUMBERS AND DATES
        # TBD SHOULD DO SOME MORE VALIDATION OF COLS IN DICT ABOVE, E.G. MAKE SURE THEY ARE NUMBERS AND DATES
        # TBD SHOULD DO SOME MORE VALIDATION OF COLS IN DICT ABOVE, E.G. MAKE SURE THEY ARE NUMBERS AND DATES
        
        # Regrouping data by TMC
        df_merged = pd.DataFrame() 
        df_grouped  = df_Min_Data_Needed.groupby(['TMC'], sort=False)
        cnt = 0
        for name, group in df_grouped:
            cnt = cnt + 1
            if df_merged.empty: 
                # This is the first TMC/Roadway, Link L = L1
                df_merged = df_merged.append(group) 
            else: 
                # This is the "cnt" TMC Roadway, Link L = L"cnt"
                df_merged = pd.merge(df_merged, group, on=['DATE', 'HOUR'], suffixes=(None, '_L' + str(cnt))) 
        
        # Rename first group so naming format is consistent (Has to be done after all merges)
        link_name_dict = { 'TMC' : 'TMC_L1',
                          'DATE': 'DATE', 
                          'HOUR': 'HOUR', 
                          'MAADT': 'MAADT_L1', 
                          'SPD_ALL': 'SPD_ALL_L1', 
                          'SPD_AT': 'SPD_AT_L1',
                          'SPD_HT': 'SPD_HT_L1', 
                          'PCT_AT': 'PCT_AT_L1', 
                          'PCT_MT': 'PCT_MT_L1', 
                          'PCT_HT': 'PCT_HT_L1', 
                          'PCT_BUS': 'PCT_BUS_L1', 
                          'PCT_MC': 'PCT_MC_L1' }
        df_merged.rename(columns=link_name_dict, inplace=True)
        
        # Add in columns for computed noise levels - will be np.nan for now
        for link in range(len(self.tmc), 0, -1): # Count backwards for easier 
                                                 # caclulation col position to 
                                                 # insert new columns
            df_merged.insert((link)*10+2+0,'SPL_AT_L' + str(link),np.nan)
            df_merged.insert((link)*10+2+1,'SPL_MT_L' + str(link),np.nan)
            df_merged.insert((link)*10+2+2,'SPL_HT_L' + str(link),np.nan)
            df_merged.insert((link)*10+2+3,'SPL_BUS_L' + str(link),np.nan)
            df_merged.insert((link)*10+2+4,'SPL_MC_L' + str(link),np.nan)
            df_merged.insert((link)*10+2+5,'SPL_Total_L' + str(link),np.nan)
        
        self.df_Traffic_Noise = df_merged
        self.number_of_hours = self.df_Traffic_Noise.shape[0]
        if self.number_of_hours == 8760:
            self.data_range = 'One Year'
        elif self.number_of_hours == 8784:
            self.data_range = 'One Leap-Year'
        elif self.number_of_hours > 8760 and self.number_of_hours < 8784:
            self.data_range = 'Possible Incomplete Leap-Year'
        elif self.number_of_hours > 8784:
            self.data_range = 'More Than One Year'
        else:
            self.data_range = 'Less Than One Year'

        self.df_DANA = df_DANA # Just for reference at this point
        
        return
    
    def Compute_Hourly_SPL_All_Veh_All_Links(self):
        # Only used if "robust speed" calculations are needed
        link_number = 0
        for link in self.tmc:
            link_number = link_number + 1
            vehicle_type = 'at' # Compute SPL for THIS link/veh/hour
            for row in self.df_Traffic_Noise.index:
                self.Compute_Hourly_SPL(vehicle_type, link_number, row)
            vehicle_type = 'mt' # Compute SPL for THIS link/veh/hour
            for row in self.df_Traffic_Noise.index:
                self.Compute_Hourly_SPL(vehicle_type, link_number, row)
            vehicle_type = 'ht' # Compute SPL for THIS link/veh/hour
            for row in self.df_Traffic_Noise.index:
                self.Compute_Hourly_SPL(vehicle_type, link_number, row)
            vehicle_type = 'bus' # Compute SPL for THIS link/veh/hour
            for row in self.df_Traffic_Noise.index:
                self.Compute_Hourly_SPL(vehicle_type, link_number, row)
            vehicle_type = 'mc' # Compute SPL for THIS link/veh/hour
            for row in self.df_Traffic_Noise.index:
                self.Compute_Hourly_SPL(vehicle_type, link_number, row)
        return
    
    def Compute_Hourly_SPL_All_Veh_All_Links_Vector(self):
        # Standard and much faster method of calculation
        # Calls Compute_Hourly_SPL_Vector for each vehicle type
        link_number = 0
        for link in self.tmc:
            link_number = link_number + 1
            vehicle_type = 'at' # Compute SPL for THIS link/veh/hour
            self.Compute_Hourly_SPL_Vector(vehicle_type, link_number)
            vehicle_type = 'mt' # Compute SPL for THIS link/veh/hour
            self.Compute_Hourly_SPL_Vector(vehicle_type, link_number)
            vehicle_type = 'ht' # Compute SPL for THIS link/veh/hour
            self.Compute_Hourly_SPL_Vector(vehicle_type, link_number)
            vehicle_type = 'bus' # Compute SPL for THIS link/veh/hour
            self.Compute_Hourly_SPL_Vector(vehicle_type, link_number)
            vehicle_type = 'mc' # Compute SPL for THIS link/veh/hour
            self.Compute_Hourly_SPL_Vector(vehicle_type, link_number)
            
            at_spl = self.df_Traffic_Noise['SPL_AT_L' + str(link_number)]
            mt_spl = self.df_Traffic_Noise['SPL_MT_L' + str(link_number)]
            ht_spl = self.df_Traffic_Noise['SPL_HT_L' + str(link_number)]
            bus_spl = self.df_Traffic_Noise['SPL_BUS_L' + str(link_number)]
            mc_spl = self.df_Traffic_Noise['SPL_MC_L' + str(link_number)]
            
            self.df_Traffic_Noise['SPL_Total_L' + str(link_number)] = \
                10*np.log10(10**(at_spl/10) + 10**(mt_spl/10) + 10**(ht_spl/10) \
                            + 10**(bus_spl/10) + 10**(mc_spl/10))
                
        return
    
    def Compute_Hourly_SPL(self, vehicle_type, link_number, row):
        # Only used if "robust speed" calculations are needed
        traffic_vol_col_name = 'MAADT_L' + str(link_number)

        spl_column_name = 'SPL_' + vehicle_type.upper() + '_L' + str(link_number)
        perc_col_name = 'PCT_' + vehicle_type.upper() + '_L' + str(link_number)

        if vehicle_type.upper() == 'AT':
            spd_col_name = 'SPD_AT_L' + str(link_number)
        elif vehicle_type.upper() == 'MC':
            spd_col_name = 'SPD_ALL_L' + str(link_number)
        else:
            spd_col_name = 'SPD_HT_L' + str(link_number)       

        hourly_traffic_vol = self.df_Traffic_Noise.loc[row, traffic_vol_col_name] * \
            self.df_Traffic_Noise.loc[row, perc_col_name]

        hourly_traffic_spd = self.df_Traffic_Noise.loc[row, spd_col_name]
        
        engine = 'cruise'
        if vehicle_type.lower() == 'ht':
            if self.link_grade[link_number-1] >= 1.5:
                engine = 'FULL_THROTTLE'
               
        self.df_Traffic_Noise.loc[row, spl_column_name] = \
            Compute_REMELs.Compute_SPL(vehicle_type, hourly_traffic_vol, hourly_traffic_spd, 'avg', engine)
        return
    
    def Compute_Hourly_SPL_Vector(self, vehicle_type, link_number):
        # standard and much faster method of calculation
        traffic_vol_col_name = 'MAADT_L' + str(link_number)

        spl_column_name = 'SPL_' + vehicle_type.upper() + '_L' + str(link_number)
        perc_col_name = 'PCT_' + vehicle_type.upper() + '_L' + str(link_number)
        
        if vehicle_type.upper() == 'AT':
            spd_col_name = 'SPD_AT_L' + str(link_number)
        elif vehicle_type.upper() == 'MC':
            spd_col_name = 'SPD_ALL_L' + str(link_number)
        else:
            spd_col_name = 'SPD_HT_L' + str(link_number)

        hourly_traffic_vol = self.df_Traffic_Noise[traffic_vol_col_name] * \
            self.df_Traffic_Noise[perc_col_name]

        hourly_traffic_spd = self.df_Traffic_Noise[spd_col_name]
        
        engine = 'cruise'
        if vehicle_type.lower() == 'ht':
            if self.link_grade[link_number-1] >= 1.5:
                engine = 'FULL_THROTTLE'
                
        self.df_Traffic_Noise[spl_column_name] = \
            Compute_REMELs.Compute_SPL(vehicle_type, hourly_traffic_vol, hourly_traffic_spd, 'avg', engine)

        return
        
