# -*- coding: utf-8 -*-
"""
Created on Wed Nov  9 18:51:51 2022

@author: aaron.hastings
"""

import pandas as pd
import numpy as np

class DANA_Noise_Data:
    # User Inputs
    # number_of_lanes         = Total Number of Lanes inboth directions, 
    #                           e.g. for 2 NB & 2 SB lanes, number_of_lanes = 4
    # median_width            = Median Width
    # near_lane_roadway_grade = Roadway Grade (in Direction of Near Lanes)
    #                         = 100 * rise / run
    #
    # df_DANA = Dataframe containing all input data except the three values above:
    #           Columns of df are generated by the DANA tool and include:
    #                TMC, DATE, HOUR, ROAD, DIRECTION, STATE, COUNTY,
    #                start_latitude, start_longitude, end_latitude, end_longitude
    #                TMC_LENGTH, road_order, f_system, thrulanes, aadt, 
    #                AADT_Single_Unit, aadt_combinations, TT_ALL_vehs, TT_PASS,
    #                TT_TRUCK, SPEED_ALL_vehs, SPEED_PASS, SPEED_TRUCK,
    #                PCT_NOISE_AUTO, PCT_NOISE_MEDIUM, PCT_NOISE_HEAVY,
    #                PCT_NOISE_BUS, PCT_NOISE_MC
    #           
    #      For a description of each of these columns, see Appendix C, 
    #           Table 4.4 on page 80 of the DANA User's Guide.
    #           https://www.fhwa.dot.gov/environment/air_quality/methodologies/
    #           dana/dana_userguide_r2.pdf
    #           - OR -
    #           https://www.fhwa.dot.gov/environment/noise/traffic_noise_model/
    #           tnm_aide_userguide/
    #
    # Change Log from TNMAide 2.0
    # 1) Refactored code into several scripts and classes
    # 2) Removed need to pass number of links. This is now computed from data
    # 3) Removed default computation of future condition, handled as a separate call with modified data
    # 4) Removed computation of worst hour of all hours of all 365 (366) days
    # 5) Intermediate dataframe created that holds all relevant hourly data, i.e.
    #    traffic volumes, speeds and noise levels
    #    Different TMCs are held in different columns instead of different rows
    #    i.e. single row for each date/hour combination
    # 6) Added data validation for improved robustness
    # 7) Where possible added data conversion for improved flexibility and robustness
       
    
    def __init__(self, df_DANA, median_width = 0.0, link_grade = (0.0), 
                 robust_speeds = False):
        # Init Steps:
        #  1) Validate Inputs
        #  2) Convert df_DANA to minimal dataframe:
        #       df_Traffic_Noise
        #       links are in different columns rather than different rows (easier sorting)
        #  3) Compute LAeq for each hour:
        #       for each link
        #       for links combined           
        
        # Validate INPUTS
        if not isinstance(median_width, (float, int)):
            print('-----DANA_Noise_Data.__init__.')
            print('-----Median width must be a non-negative, finite number.')   
            # TBD add GUI error message
            return None
        if not np.isfinite(median_width):
            print('-----DANA_Noise_Data.__init__.')
            print('-----Median width must be a non-negative, finite number.')   
            # TBD add GUI error message
            return None
        if median_width < 0.0:
            print('-----DANA_Noise_Data.__init__.')
            print('-----Median width must be a non-negative, finite number.')   
            # TBD add GUI error message
            return None
        if isinstance(link_grade, list):
            # Convert to preferred format, tuple
            link_grade = tuple(link_grade)     
        if isinstance(link_grade, np.ndarray):
            link_grade = tuple(link_grade)
        if not isinstance(link_grade, tuple):
            if isinstance(link_grade, int):
                # Convert int to preferred format, float (done seperately for readability)
                link_grade = float(link_grade)
            if not isinstance(link_grade, float):
                print('-----DANA_Noise_Data.__init__.')
                print('-----Roadway grade must be a number between [-8.0 and 8.0].')   
                # TBD add GUI error message
                return None
            if abs(link_grade) > 8.0:
                print('-----DANA_Noise_Data.__init__.')
                print('-----Roadway grade must be a number between [-8.0 and 8.0].')   
                # TBD add GUI error message
                return None
        else: # it is a tuple
            tmp = []    
            for grade in link_grade:
                if not isinstance(grade, (float, int)):
                    print('-----DANA_Noise_Data.__init__.')
                    print('-----Roadway grade must be a number between [-8.0 and 8.0].')   
                    # TBD add GUI error message
                    return None
                tmp.append(float(grade))
                if abs(grade) > 8.0:
                    print('-----DANA_Noise_Data.__init__.')
                    print('-----Roadway grade must be a number between [-8.0 and 8.0].')   
                    # TBD add GUI error message
                    return None
            link_grade = tuple(tmp)                    
        
        self.median_width = float(median_width)
        self.link_grade = link_grade
        self.robust_speeds = robust_speeds
        
        # Validate the Dataframe Input
        self.Validate_Data(df_DANA)
        if self.df_Traffic_Noise is None:
            return None
        
        # Final validation of consistency between dataframe and other user inputs
        if isinstance(self.tmc, tuple):
            number_of_TMCs = len(self.tmc)
        else:
            number_of_TMCs = 1
            
        if isinstance(self.link_grade, tuple):
            number_of_grades = len(self.link_grade)
        else:
            number_of_grades = 1
        
        if number_of_TMCs != number_of_grades:
            print('-----DANA_Noise_Data.__init__.')
            print('-----Must provide a roadway grade for each link.')   
            # TBD add GUI error message
            return None
            
        return
        
        
    def Validate_Data(self, df_DANA):
        # Standard format is for one year of hourly data for two adjacent links
        #      can be standard or leap year
        # Non-stanard format includes only one link, or fewer than a year's data
        # Number of Hourly Samples in Standard Year = 365 * 24 =  8,760 per link
        #                                                      = 17,520 per paired links
        # Number of Hourly Samples in Leap Year = 366 * 24     =  8,784 per link
        #                                                      = 17,568 per paired links
        # 
        # Expected Dataframe Columns
        # ['TMC' 'DATE' 'HOUR' 'ROAD' 'DIRECTION' 'STATE' 'COUNTY' 'START_LATITUDE'
        # 'START_LONGITUDE' 'END_LATITUDE' 'END_LONGITUDE' 'TMC_LENGTH'
        # 'ROAD_ORDER' 'F_SYSTEM' 'THRULANES' 'AADT' 'AADT SINGLE UNIT'
        # 'AADT_COMBINATIONS' 'TT_ALL_VEHS' 'TT_PASS' 'TT_TRUCK' 'SPEED_ALL_VEHS'
        # 'SPEED_PASS' 'SPEED_TRUCK' 'PCT_NOISE_AUTO' 'PCT_NOISE_MEDIUM'
        # 'PCT_NOISE_HEAVY' 'PCT_NOISE_BUS' 'PCT_NOISE_MC']
        #
        # Note: only 'AADT' is used for volumes, not 'AADT SINGLE UNIT' or 'AADT_COMBINATIONS'
        # Note: 'SPEED_ALL_VEHS' is used only for MCs
        #       'SPEED_PASS' is used only for Autos
        #       'SPEED_TRUCK' is used for MTs, HTs and Buses
        #
        # Data Needed for Each Row in the dataframe:
        # DATE, HOUR, AADT, SPEED_ALL_VEHS, SPEED_PASS, SPEED_TRUCK, PCT_NOISE_AUTO,
        # PCT_NOISE_MEDIUM, PCT_NOISE_HEAVY, PCT_NOISE_BUS, PCT_NOISE_MC
        #
        # These columns will ulitmately be renamed to 
        #
        # DATE, HOUR, AADT, SPD_ALL, SPD_AT, SPD_HT, PCT_AT,
        # PCT_MT, PCT_HT, PCT_BUS, PCT_MC
        #
        #
        # All others can be stored once at the class level
        
        # Reset index
        df_DANA.reset_index(drop=True, inplace=True)
        
        # Make all column names upper case for robustness
        col_names = df_DANA.columns.values
        new_name_dict = {} 
        for name in col_names:
            new_name_dict[name] = name.upper() 
        df_DANA.rename(columns=new_name_dict, inplace=True)
        
        # TMCS
        ######################################################################
        # Get the TMCs
        if any(df_DANA.columns.values == 'TMC'):
            self.tmc = tuple(pd.unique(df_DANA['TMC']))
            self.number_of_links = len(self.tmc)
            # Create dictionary associating each TMC with and L# label
            self.tmc_dictionary = {}
            cnt = 0
            for tmc in self.tmc:
                cnt = cnt + 1
                self.tmc_dictionary['L' + str(cnt)] = tmc 
            if self.number_of_links < 1:
                print('-----DANA_Noise_Data.__init__.')
                print('-----TMC column of input dataframe was empty.')   
                # TBD add GUI error message
                self.df_Traffic_Noise = None
                return
        else:
            print('-----DANA_Noise_Data.__init__.')
            print('-----TMC data must be labeled in df_DANA input dataframe.')   
            # TBD add GUI error message
            self.df_Traffic_Noise = None
            return
        
        # Get indeces for TMC transition
        self.link_start_idx = np.array([],int)
        for tmc in self.tmc:
            self.link_start_idx = np.append(self.link_start_idx, df_DANA.TMC.eq(tmc).idxmax())
        
        # ROAD NAMES
        ######################################################################
        # Get the Road Names
        self.road_names = []
        if any(df_DANA.columns.values == 'ROAD'):
            for idx in self.link_start_idx:
                self.road_names.append(df_DANA.loc[idx,'ROAD'])   
        else:
            print('-----DANA_Noise_Data.__init__.')
            print('-----Warning, no roadway name data found. Default names being used.')   
            # TBD add GUI error message
            cnt = 0
            for idx in self.link_start_idx:
                cnt = cnt + 1
                self.road_names.append('ROAD ' + str(cnt))   

        # ROAD DIRECTION
        ######################################################################
        # Get the Direction for each TMC
        self.directions = []
        if any(df_DANA.columns.values == 'DIRECTION'):
            for idx in self.link_start_idx:
                self.directions.append(df_DANA.loc[idx,'DIRECTION'])   
        else:
            print('-----DANA_Noise_Data.__init__.')
            print('-----Warning, no roadway direction data found. NA being used for all TMCs.')   
            # TBD add GUI error message
            for idx in self.link_start_idx:
                self.directions.append('NA')  

        # ROAD STATE
        ######################################################################
        # Get the State that each TMC resides in
        self.state = []
        if any(df_DANA.columns.values == 'STATE'):
            for idx in self.link_start_idx:
                self.state.append(df_DANA.loc[idx,'STATE'])   
        else:
            print('-----DANA_Noise_Data.__init__.')
            print('-----Warning, no roadway state data found. NA being used for all TMCs.')   
            # TBD add GUI error message
            for idx in self.link_start_idx:
                self.state.append('NA')  
        
        # ROAD COUNTY
        ######################################################################
        # Get the COUNTY that each TMC resides in
        self.county = []
        if any(df_DANA.columns.values == 'COUNTY'):
            for idx in self.link_start_idx:
                self.county.append(df_DANA.loc[idx,'COUNTY'])   
        else:
            print('-----DANA_Noise_Data.__init__.')
            print('-----Warning, no roadway county data found. NA being used for all TMCs.')   
            # TBD add GUI error message
            for idx in self.link_start_idx:
                self.county.append('NA')
                
        # ROAD START_LATITUDE
        ######################################################################
        # Get the START_LATITUDE for each TMC
        self.start_lat = []
        if any(df_DANA.columns.values == 'START_LATITUDE'):
            for idx in self.link_start_idx:
                self.start_lat.append(df_DANA.loc[idx,'START_LATITUDE'])   
        else:
            print('-----DANA_Noise_Data.__init__.')
            print('-----Warning, no roadway start lattitude data found. 0.0 being used for all TMCs.')   
            # TBD add GUI error message
            for idx in self.link_start_idx:
                self.start_lat.append(0.0)

        # ROAD START_LONGITUDE
        ######################################################################
        # Get the START_LATITUDE for each TMC
        self.start_long = []
        if any(df_DANA.columns.values == 'START_LONGITUDE'):
            for idx in self.link_start_idx:
                self.start_long.append(df_DANA.loc[idx,'START_LONGITUDE'])   
        else:
            print('-----DANA_Noise_Data.__init__.')
            print('-----Warning, no roadway start longitude data found. 0.0 being used for all TMCs.')   
            # TBD add GUI error message
            for idx in self.link_start_idx:
                self.start_long.append(0.0)
                
        # ROAD END_LATITUDE
        ######################################################################
        # Get the START_LATITUDE for each TMC
        self.end_lat = []
        if any(df_DANA.columns.values == 'END_LATITUDE'):
            for idx in self.link_start_idx:
                self.end_lat.append(df_DANA.loc[idx,'END_LATITUDE'])   
        else:
            print('-----DANA_Noise_Data.__init__.')
            print('-----Warning, no roadway end lattitude data found. 0.0 being used for all TMCs.')   
            # TBD add GUI error message
            for idx in self.link_start_idx:
                self.end_lat.append(0.0)

        # ROAD END_LONGITUDE
        ######################################################################
        # Get the START_LATITUDE for each TMC
        self.end_long = []
        if any(df_DANA.columns.values == 'END_LONGITUDE'):
            for idx in self.link_start_idx:
                self.end_long.append(df_DANA.loc[idx,'END_LONGITUDE'])   
        else:
            print('-----DANA_Noise_Data.__init__.')
            print('-----Warning, no roadway end longitude data found. 0.0 being used for all TMCs.')   
            # TBD add GUI error message
            for idx in self.link_start_idx:
                self.end_long.append(0.0)

        # ROAD TMC_LENGTH
        ######################################################################
        # Get the START_LATITUDE for each TMC
        self.tmc_length = []
        if any(df_DANA.columns.values == 'TMC_LENGTH'):
            for idx in self.link_start_idx:
                self.tmc_length.append(df_DANA.loc[idx,'TMC_LENGTH'])   
        else:
            print('-----DANA_Noise_Data.__init__.')
            print('-----Warning, no roadway length data found. 0.0 being used for all TMCs.')   
            # TBD add GUI error message
            for idx in self.link_start_idx:
                self.tmc_length.append(0.0)

        # Create new dataframe using only needed columns
        df_Min_Data_Needed = df_DANA[['TMC', 'DATE', 'HOUR', 'AADT', 'SPEED_ALL_VEHS', 'SPEED_PASS', 'SPEED_TRUCK', 
                   'PCT_NOISE_AUTO', 'PCT_NOISE_MEDIUM', 'PCT_NOISE_HEAVY', 'PCT_NOISE_BUS', 'PCT_NOISE_MC']].copy()

        # Move TMC to be after Hour - This is the last time that it is this easy to switch
        df_Min_Data_Needed.insert(2, 'TMC', df_Min_Data_Needed.pop('TMC'))

        # Final Renaming before regrouping
        link_name_dict = { 'DATE': 'DATE', 
                   'HOUR': 'HOUR', 
                   'AADT': 'AADT', 
                   'SPEED_ALL_VEHS': 'SPD_ALL', 
                   'SPEED_PASS': 'SPD_AT',
                   'SPEED_TRUCK': 'SPD_HT', 
                   'PCT_NOISE_AUTO': 'PCT_AT', 
                   'PCT_NOISE_MEDIUM': 'PCT_MT', 
                   'PCT_NOISE_HEAVY': 'PCT_HT', 
                   'PCT_NOISE_BUS': 'PCT_BUS', 
                   'PCT_NOISE_MC': 'PCT_MC' }
        df_Min_Data_Needed.rename(columns=link_name_dict, inplace=True)
        
        # TBD NEED TO DO SOME MORE VALIDATION OF COLS IN DICT ABOVE, E.G. MAKE SURE THEY ARE NUMBERS AND DATES
        # TBD NEED TO DO SOME MORE VALIDATION OF COLS IN DICT ABOVE, E.G. MAKE SURE THEY ARE NUMBERS AND DATES
        # TBD NEED TO DO SOME MORE VALIDATION OF COLS IN DICT ABOVE, E.G. MAKE SURE THEY ARE NUMBERS AND DATES
        # TBD NEED TO DO SOME MORE VALIDATION OF COLS IN DICT ABOVE, E.G. MAKE SURE THEY ARE NUMBERS AND DATES
        # TBD NEED TO DO SOME MORE VALIDATION OF COLS IN DICT ABOVE, E.G. MAKE SURE THEY ARE NUMBERS AND DATES
        # TBD NEED TO DO SOME MORE VALIDATION OF COLS IN DICT ABOVE, E.G. MAKE SURE THEY ARE NUMBERS AND DATES
        # TBD NEED TO DO SOME MORE VALIDATION OF COLS IN DICT ABOVE, E.G. MAKE SURE THEY ARE NUMBERS AND DATES
        # TBD NEED TO DO SOME MORE VALIDATION OF COLS IN DICT ABOVE, E.G. MAKE SURE THEY ARE NUMBERS AND DATES
        # TBD NEED TO DO SOME MORE VALIDATION OF COLS IN DICT ABOVE, E.G. MAKE SURE THEY ARE NUMBERS AND DATES
        
        # Regrouping data by TMC
        df_merged = pd.DataFrame() 
        df_grouped  = df_Min_Data_Needed.groupby(['TMC'])
        cnt = 0
        for name, group in df_grouped:
            cnt = cnt + 1
            if df_merged.empty: 
                df_merged = df_merged.append(group) 
            else: 
                df_merged = pd.merge(df_merged, group, on=['DATE', 'HOUR'], suffixes=(None, '_L' + str(cnt))) 
        
        # Rename first group so naming format is consistent (Has to be done after all merges)
        link_name_dict = { 'TMC' : 'TMC_L1',
                          'DATE': 'DATE', 
                          'HOUR': 'HOUR', 
                          'AADT': 'AADT_L1', 
                          'SPD_ALL': 'SPD_ALL_L1', 
                          'SPD_AT': 'SPD_AT_L1',
                          'SPD_HT': 'SPD_HT_L1', 
                          'PCT_AT': 'PCT_AT_L1', 
                          'PCT_MT': 'PCT_MT_L1', 
                          'PCT_HT': 'PCT_HT_L1', 
                          'PCT_BUS': 'PCT_BUS_L1', 
                          'PCT_MC': 'PCT_MC_L1' }
        df_merged.rename(columns=link_name_dict, inplace=True)
        
        # Add in columns for computed noise levels - will be np.nan for now
        for link in range(len(self.tmc), 0, -1): # Count backwards for easier insertion col calcs
            df_merged.insert((link)*10+2+0,'SPL_AT_L' + str(link),np.nan)
            df_merged.insert((link)*10+2+1,'SPL_MT_L' + str(link),np.nan)
            df_merged.insert((link)*10+2+2,'SPL_HT_L' + str(link),np.nan)
            df_merged.insert((link)*10+2+3,'SPL_BUS_L' + str(link),np.nan)
            df_merged.insert((link)*10+2+4,'SPL_MC_L' + str(link),np.nan)
            df_merged.insert((link)*10+2+5,'SPL_Total_L' + str(link),np.nan)
        
        self.df_Traffic_Noise = df_merged
        self.number_of_hours = self.df_Traffic_Noise.shape[0]
        if self.number_of_hours == 8760:
            self.data_range = 'One Year'
        elif self.number_of_hours == 8784:
            self.data_range = 'One Leap-Year'
        elif self.number_of_hours > 8760 and self.number_of_hours < 8784:
            self.data_range = 'Possible Incomplete Leap-Year'
        elif self.number_of_hours > 8784:
            self.data_range = 'More Than One Year'
        else:
            self.data_range = 'Less Than One Year'

        self.df_DANA = df_DANA # Just for reference at this point
        
        return
    
    def Compute_Hourly_SPL():
        pass
        
    def Compute_Daily_Metrics():
        pass
    
    def Determine_Worst_Hour():
        pass
    
    def Plot_Hourly_SPL():
        pass
    
    def Plot_Daily_Metrics():
        pass
    
    def Plot_Hourly_Traffic_Histograms():
        pass

    def Plot_Daily_Traffic_Histograms():
        pass
    

    def Update_Traffic_Volumes():
        pass